<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>DDos 攻击</title>
    <link href="/2024/09/11/DDos-%E6%94%BB%E5%87%BB/"/>
    <url>/2024/09/11/DDos-%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="DDos-攻击"><a href="#DDos-攻击" class="headerlink" title="DDos 攻击"></a>DDos 攻击</h1><blockquote><p>最近阅读了一篇关于发表在 Usenix Security 24 上的有关 DDos 攻击防御的论文，借此机会总结一下 DDos 攻击的相关知识。</p></blockquote><h2 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h2><p>DDos （Distributed Denial of Service）攻击是一种通过向目标服务器发送大量请求，使其无法正常处理合法请求的攻击方式:  </p><ul><li>攻击者通过控制大量僵尸主机，向目标服务器发送大量请求，使目标机器停止提供服务或资源访问</li><li>资源包括磁盘空间、内存、进程甚至网络带宽</li></ul><p>DDoS 攻击主要利用“僵尸网络”对 TCP 三次握手过程中第一次握手（SYN）和第二次握手（SYN-ACK）步骤来发起攻击。下面介绍两种常见的攻击： SYN Flood 和 ACK Flood。</p><ul><li>SYN Flood 攻击：攻击者发送大量 SYN 请求，但不进行后续的第二次握手（SYN-ACK）和第三次握手（ACK）。这导致服务器资源被大量消耗，因为服务器会为每个 SYN 请求保留资源，等待确认。当大量的SYN请求堆积在服务器上，服务器的处理能力将被严重削弱，无法处理正常的请求。</li><li>ACK Flood 攻击：攻击者发送大量 ACK 请求，但不进行第一次握手（SYN）。这使得服务器在收到ACK请求时，无法找到匹配的 SYN 请求，从而消耗服务器的处理资源。服务器在收到大量无用的 ACK 数据包时，无法正常响应其他请求。</li></ul><h2 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h2><h3 id="SYN-Cookies"><a href="#SYN-Cookies" class="headerlink" title="SYN Cookies"></a>SYN Cookies</h3><p>TCP 服务器收到 SYN 包后，在发送 SYN + ACK 包前，服务器要先分配好一个数据区专门服务于这个即将形成的 TCP 连接。一般把收到 SYN 包而还未收到 ACK 包时的连接状态称为半打开连接(Half-open Connection) 。<br>攻击者通过伪造 IP 地址，向服务器发送大量的 SYN 包，服务器会为每个 SYN 包分配一个数据区，但是不会收到 ACK 包，这样服务器的资源就会被耗尽。</p><p>SYN Cookie 是对 TCP 服务器端的三次握手做一些修改，它的原理是：</p><ul><li>在TCP服务器接收到 SYN 包并返回 SYN + ACK 包时，不分配一个专门的数据区，而是根据这个 SYN 包计算出一个 cookie 值。</li><li>这个 cookie 作为将要返回的 SYN ACK 包的初始序列号。当客户端返回一个 ACK 包时，根据包头信息计算 cookie，与返回的确认序列号(初始序列号 + 1)进行对比，如果相同，则是一个正常连接，然后，分配资源，建立连接。</li></ul><h4 id="Cookie-的生成"><a href="#Cookie-的生成" class="headerlink" title="Cookie 的生成"></a>Cookie 的生成</h4><blockquote><p>cookie的计算应该包含本次连接的状态信息，使攻击者不能伪造</p></blockquote><p>服务器收到一个 SYN 包，计算一个消息摘要 Mac<br>$$<br>mac &#x3D; MAC(A, k)<br>$$<br>在 Linux 中，MAC 为 SHA1，A 为 TCP SYN 包的部分字段，k 为服务器的密钥。<br>$$<br>A &#x3D; SOURCE_IP || SOURCE_PORT || DST_IP || DST_PORT || t || MSSIND<br>$$</p><h4 id="SYN-Cookie-的缺点"><a href="#SYN-Cookie-的缺点" class="headerlink" title="SYN Cookie 的缺点"></a>SYN Cookie 的缺点</h4><ul><li>MSS 的编码只有 3 位，因此最多只能使用 8 种 MSS 值</li><li>服务器必须拒绝客户端 SYN 报文中的其他只在 SYN 和 SYN+ACK 中协商的选项，原因是服务器没有地方可以保存这些选项，比如 Wscale 和 SACK 增加了密码学运算</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>网安</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DP</title>
    <link href="/2024/09/06/DP/"/>
    <url>/2024/09/06/DP/</url>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><blockquote><p>DP 问题</p></blockquote><span id="more"></span><h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><p>记忆化搜索是一种通过记录已经遍历过的状态的信息，从而避免对同一状态重复遍历的搜索实现方式。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ol><li>把这道题的 dp 状态和方程写出来</li><li>根据它们写出 dfs 函数</li><li>添加记忆化数组</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> MMAX = <span class="hljs-number">100</span>;<br><span class="hljs-type">int</span> tcost[MMAX + <span class="hljs-number">10</span>];<br><span class="hljs-type">int</span> mget[MMAX + <span class="hljs-number">10</span>];<br><span class="hljs-type">int</span> mem[MMAX + <span class="hljs-number">5</span>][<span class="hljs-number">1000</span> + <span class="hljs-number">5</span>];<br><span class="hljs-type">int</span> t, n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> tleft)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (mem[pos][tleft] != <span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">return</span> mem[pos][tleft];<br>    <span class="hljs-keyword">if</span> (pos == n + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> mem[pos][tleft] = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> dfs1, dfs2 = <span class="hljs-number">-0x80000000</span>;<br>    dfs1 = <span class="hljs-built_in">dfs</span>(pos + <span class="hljs-number">1</span>, tleft);<br>    <span class="hljs-keyword">if</span> (tleft &gt;= tcost[pos])<br>        dfs2 = <span class="hljs-built_in">dfs</span>(pos + <span class="hljs-number">1</span>, tleft - tcost[pos]) + mget[pos];<br>    <span class="hljs-keyword">return</span> mem[pos][tleft] = <span class="hljs-built_in">max</span>(dfs1, dfs2);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(mem, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(mem));<br>    cin &gt;&gt; t &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        cin &gt;&gt; tcost[i] &gt;&gt; mget[i];<br>    cout &lt;&lt; <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, t) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="背包-DP"><a href="#背包-DP" class="headerlink" title="背包 DP"></a>背包 DP</h2><h3 id="01-背包问题"><a href="#01-背包问题" class="headerlink" title="01 背包问题"></a>01 背包问题</h3><p>状态转移方程如下<br>$$<br>f[j] &#x3D; \max(f[j], f[j - w[i]] + v[i])<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> N, M;<br><span class="hljs-type">int</span> tcost[NMAX + <span class="hljs-number">5</span>];<br><span class="hljs-type">int</span> mget[NMAX + <span class="hljs-number">5</span>];<br><span class="hljs-type">int</span> ans[MMAX + <span class="hljs-number">5</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; N &gt;&gt; M;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++)<br>        cin &gt;&gt; tcost[i] &gt;&gt; mget[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = M; j &gt;= tcost[i]; j--)<br>            ans[j] = <span class="hljs-built_in">max</span>(ans[j - tcost[i]] + mget[i], ans[j]);<br>    &#125;<br>    cout &lt;&lt; ans[M] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h3><p>完全背包模型与 0-1 背包类似，与 0-1 背包的区别仅在于一个物品可以选取无限次，而非仅能选取一次。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> tcost[MMAX + <span class="hljs-number">5</span>];<br><span class="hljs-type">int</span> mget[MMAX + <span class="hljs-number">5</span>];<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> ans[TMAX + <span class="hljs-number">5</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; t &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>        cin &gt;&gt; tcost[i] &gt;&gt; mget[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = tcost[i]; j &lt;= t; j++)<br>            ans[j] = <span class="hljs-built_in">max</span>(ans[j - tcost[i]] + mget[i], ans[j]);<br>    &#125;<br>    cout &lt;&lt; ans[t] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h3><p>多重背包问题是 0-1 背包问题的一个变种，与 0-1 背包的区别在于每种物品的数量不再是 1 个，而是有限个。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> weight = W; weight &gt;= w[i]; weight--) &#123;<br>    <span class="hljs-comment">// 多遍历一层物品数量</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k * w[i] &lt;= weight &amp;&amp; k &lt;= cnt[i]; k++) &#123;<br>      dp[weight] = <span class="hljs-built_in">max</span>(dp[weight], dp[weight - k * w[i]] + k * v[i]);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="混合背包问题"><a href="#混合背包问题" class="headerlink" title="混合背包问题"></a>混合背包问题</h3><p>混合背包就是将前面三种的背包问题混合起来，有的只能取一次，有的能取无限次，有的只能取 k 次。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">for (循环物品种类) &#123;<br>  if (是 0 - 1 背包)<br>    套用 0 - 1 背包代码;<br>  else if (是完全背包)<br>    套用完全背包代码;<br>  else if (是多重背包)<br>    套用多重背包代码;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二维背包问题"><a href="#二维背包问题" class="headerlink" title="二维背包问题"></a>二维背包问题</h3><p>0-1 背包问题，可是不同的是选一个物品会消耗两种价值（经费、时间），只需在状态中增加一维存放第二种价值即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k++)<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = m; i &gt;= mi; i--)    <span class="hljs-comment">// 对经费进行一层枚举</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = t; j &gt;= ti; j--)  <span class="hljs-comment">// 对时间进行一层枚举</span><br>      dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[i - mi][j - ti] + <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h3 id="分组背包问题"><a href="#分组背包问题" class="headerlink" title="分组背包问题"></a>分组背包问题</h3><p>从「在所有物品中选择一件」变成了「从当前组中选择一件」，于是就对每一组进行一次 0-1 背包就可以了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= ts; k++)          <span class="hljs-comment">// 循环每一组</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = m; i &gt;= <span class="hljs-number">0</span>; i--)         <span class="hljs-comment">// 循环背包容量</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= cnt[k]; j++)  <span class="hljs-comment">// 循环该组的每一个物品</span><br>      <span class="hljs-keyword">if</span> (i &gt;= w[t[k][j]])             <span class="hljs-comment">// 背包容量充足</span><br>        dp[i] = <span class="hljs-built_in">max</span>(dp[i],<br>                    dp[i - w[t[k][j]]] + c[t[k][j]]);  <span class="hljs-comment">// 像0-1背包一样状态转移</span><br></code></pre></td></tr></table></figure><h3 id="背包的第-k-优解"><a href="#背包的第-k-优解" class="headerlink" title="背包的第 k 优解"></a>背包的第 k 优解</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(dp));<br><span class="hljs-type">int</span> i, j, p, x, y, z;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;K);<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;w[i]);<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;c[i]);<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>  <span class="hljs-keyword">for</span> (j = m; j &gt;= c[i]; j--) &#123;<br>    <span class="hljs-keyword">for</span> (p = <span class="hljs-number">1</span>; p &lt;= K; p++) &#123;<br>      a[p] = dp[j - c[i]][p] + w[i];<br>      b[p] = dp[j][p];<br>    &#125;<br>    a[p] = b[p] = <span class="hljs-number">-1</span>;<br>    x = y = z = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (z &lt;= K &amp;&amp; (a[x] != <span class="hljs-number">-1</span> || b[y] != <span class="hljs-number">-1</span>)) &#123;<br>      <span class="hljs-keyword">if</span> (a[x] &gt; b[y])<br>        dp[j][z] = a[x++];<br>      <span class="hljs-keyword">else</span><br>        dp[j][z] = b[y++];<br>      <span class="hljs-keyword">if</span> (dp[j][z] != dp[j][z - <span class="hljs-number">1</span>]) z++;<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, dp[m][K]);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>OI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Algorithm</title>
    <link href="/2024/08/16/Algorithm/"/>
    <url>/2024/08/16/Algorithm/</url>
    
    <content type="html"><![CDATA[<h1 id="图论算法"><a href="#图论算法" class="headerlink" title="图论算法"></a>图论算法</h1><blockquote><p>机考前的临时抱佛脚</p></blockquote><span id="more"></span><h2 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h2><h3 id="直接存边"><a href="#直接存边" class="headerlink" title="直接存边"></a>直接存边</h3><p>使用一个数组来存边，数组中的每个元素都包含一条边的起点与终点（带边权的图还包含边权）。（或者使用多个数组分别存起点，终点和边权。）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<br>  <span class="hljs-type">int</span> u, v;<br>&#125;;<br><br><span class="hljs-type">int</span> n, m;<br>vector&lt;Edge&gt; e;<br>vector&lt;<span class="hljs-type">bool</span>&gt; vis;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find_edge</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (e[i].u == u &amp;&amp; e[i].v == v) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  cin &gt;&gt; n &gt;&gt; m;<br>  vis.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>);<br>  e.<span class="hljs-built_in">resize</span>(m + <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) cin &gt;&gt; e[i].u &gt;&gt; e[i].v;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>使用一个二维数组 adj 来存边，其中 adj[u][v] 为 1 表示存在 u 到 v 的边，为 0 表示不存在。如果是带边权的图，可以在 adj[u][v] 中存储 u 到 v 的边的边权。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, m;<br>vector&lt;<span class="hljs-type">bool</span>&gt; vis;<br>vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt; &gt; adj;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find_edge</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123; <span class="hljs-keyword">return</span> adj[u][v]; &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  cin &gt;&gt; n &gt;&gt; m;<br>  vis.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>);<br>  adj.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>));<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>    <span class="hljs-type">int</span> u, v;<br>    cin &gt;&gt; u &gt;&gt; v;<br>    adj[u][v] = <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n, m;<br>vector&lt;<span class="hljs-type">bool</span>&gt; vis;<br>vector&lt;<span class="hljs-type">int</span>&gt; head, nxt, to;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>  nxt.<span class="hljs-built_in">push_back</span>(head[u]);<br>  head[u] = to.<span class="hljs-built_in">size</span>();<br>  to.<span class="hljs-built_in">push_back</span>(v);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find_edge</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = head[u]; ~i; i = nxt[i]) &#123;  <span class="hljs-comment">// ~i 表示 i != -1</span><br>    <span class="hljs-keyword">if</span> (to[i] == v) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (vis[u]) <span class="hljs-keyword">return</span>;<br>  vis[u] = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = head[u]; ~i; i = nxt[i]) <span class="hljs-built_in">dfs</span>(to[i]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  cin &gt;&gt; n &gt;&gt; m;<br><br>  vis.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>);<br>  head.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>    <span class="hljs-type">int</span> u, v;<br>    cin &gt;&gt; u &gt;&gt; v;<br>    <span class="hljs-built_in">add</span>(u, v);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="图搜索算法"><a href="#图搜索算法" class="headerlink" title="图搜索算法"></a>图搜索算法</h2><h3 id="深度优先搜索（DFS）"><a href="#深度优先搜索（DFS）" class="headerlink" title="深度优先搜索（DFS）"></a>深度优先搜索（DFS）</h3><p>DFS 的栈实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; adj;  <span class="hljs-comment">// 邻接表</span><br>vector&lt;<span class="hljs-type">bool</span>&gt; vis;         <span class="hljs-comment">// 记录节点是否已经遍历</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> </span>&#123;<br>  stack&lt;<span class="hljs-type">int</span>&gt; st;<br>  st.<span class="hljs-built_in">push</span>(s);<br>  vis[s] = <span class="hljs-literal">true</span>;<br><br>  <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>    <span class="hljs-type">int</span> u = st.<span class="hljs-built_in">top</span>();<br>    st.<span class="hljs-built_in">pop</span>();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : adj[u]) &#123;<br>      <span class="hljs-keyword">if</span> (!vis[v]) &#123;<br>        vis[v] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 确保栈里没有重复元素</span><br>        st.<span class="hljs-built_in">push</span>(v);<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="广度优先搜索（BFS）"><a href="#广度优先搜索（BFS）" class="headerlink" title="广度优先搜索（BFS）"></a>广度优先搜索（BFS）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>  <span class="hljs-keyword">while</span> (!Q.<span class="hljs-built_in">empty</span>()) Q.<span class="hljs-built_in">pop</span>();<br>  Q.<span class="hljs-built_in">push</span>(u);<br>  vis[u] = <span class="hljs-number">1</span>;<br>  d[u] = <span class="hljs-number">0</span>;<br>  p[u] = <span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">while</span> (!Q.<span class="hljs-built_in">empty</span>()) &#123;<br>    u = Q.<span class="hljs-built_in">front</span>();<br>    Q.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = head[u]; i; i = e[i].nxt) &#123;<br>      <span class="hljs-keyword">if</span> (!vis[e[i].to]) &#123;<br>        Q.<span class="hljs-built_in">push</span>(e[i].to);<br>        vis[e[i].to] = <span class="hljs-number">1</span>;<br>        d[e[i].to] = d[u] + <span class="hljs-number">1</span>;<br>        p[e[i].to] = u;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">restore</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>  vector&lt;<span class="hljs-type">int</span>&gt; res;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v = x; v != <span class="hljs-number">-1</span>; v = p[v]) &#123;<br>    res.<span class="hljs-built_in">push_back</span>(v);<br>  &#125;<br>  std::<span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; res.<span class="hljs-built_in">size</span>(); ++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, res[i]);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>OI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data Structure</title>
    <link href="/2024/08/13/Data-Structure/"/>
    <url>/2024/08/13/Data-Structure/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><blockquote><p>机考前的临时抱佛脚</p></blockquote><span id="more"></span><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈的修改与访问是按照后进先出的原则进行的，因此栈通常被称为是后进先出（last in first out）表，简称 LIFO 表。</p><h3 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h3><p>C++ 中的 STL 提供了一个容器 <code>std::stack</code>，使用前需要引入 <code>stack</code> 头文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// clang-format off</span><br><span class="hljs-keyword">template</span>&lt;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>,<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span> = std::deque&lt;T&gt;<br>&gt; <span class="hljs-keyword">class</span> stack;<br><span class="hljs-comment">// 新建两个栈 st1 和 st2</span><br>std::stack&lt;<span class="hljs-type">int</span>&gt; st1, st2;<br><span class="hljs-comment">// 为 st1 装入 1</span><br>st<span class="hljs-number">1.</span><span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br><span class="hljs-comment">// 将 st1 赋值给 st2</span><br>st2 = st1;<br><span class="hljs-comment">// 输出 st2 的栈顶元素</span><br>cout &lt;&lt; st<span class="hljs-number">2.</span><span class="hljs-built_in">top</span>() &lt;&lt; endl;<br><span class="hljs-comment">// 输出: 1</span><br></code></pre></td></tr></table></figure><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列（queue）是一种具有「先进入队列的元素一定先出队列」性质的表。由于该性质，队列通常也被称为先进先出（first in first out）表，简称 FIFO 表。</p><h3 id="STL-1"><a href="#STL-1" class="headerlink" title="STL"></a>STL</h3><p>C++ 在 STL 中提供了一个容器 <code>std::queue</code>，使用前需要先引入 <code>queue</code> 头文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::queue&lt;<span class="hljs-type">int</span>&gt; q1, q2;<br><span class="hljs-comment">// 向 q1 的队尾插入 1</span><br>q<span class="hljs-number">1.</span><span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br><span class="hljs-comment">// 将 q1 赋值给 q2</span><br>q2 = q1;<br><span class="hljs-comment">// 输出 q2 的队首元素</span><br>std::cout &lt;&lt; q<span class="hljs-number">2.f</span>ront() &lt;&lt; std::endl;<br><span class="hljs-comment">// 输出: 1</span><br></code></pre></td></tr></table></figure><h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><p>双端队列是指一个可以在队首&#x2F;队尾插入或删除元素的队列。相当于是栈与队列功能的结合。</p><h3 id="STL-2"><a href="#STL-2" class="headerlink" title="STL"></a>STL</h3><p>C++ 在 STL 中也提供了一个容器 <code>std::deque</code>，使用前需要先引入 <code>deque</code> 头文件</p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>哈希表又称散列表，一种以「key-value」形式存储数据的数据结构。所谓以「key-value」形式存储数据，是指任意的键值 key 都唯一对应到内存中的某个位置。只需要输入查找的键值，就可以快速地找到其对应的 value。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">hash_map</span> &#123;  <span class="hljs-comment">// 哈希表模板</span><br><br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">data</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> u;<br>    <span class="hljs-type">int</span> v, nex;<br>  &#125;;  <span class="hljs-comment">// 前向星结构</span><br><br>  data e[SZ &lt;&lt; <span class="hljs-number">1</span>];  <span class="hljs-comment">// SZ 是 const int 表示大小</span><br>  <span class="hljs-type">int</span> h[SZ], cnt;<br><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> u)</span> </span>&#123; <span class="hljs-keyword">return</span> (u % SZ + SZ) % SZ; &#125;<br><br>  <span class="hljs-comment">// 这里使用 (u % SZ + SZ) % SZ 而非 u % SZ 的原因是</span><br>  <span class="hljs-comment">// C++ 中的 % 运算无法将负数转为正数</span><br><br>  <span class="hljs-type">int</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">long</span> <span class="hljs-type">long</span> u) &#123;<br>    <span class="hljs-type">int</span> hu = <span class="hljs-built_in">hash</span>(u);  <span class="hljs-comment">// 获取头指针</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[hu]; i; i = e[i].nex)<br>      <span class="hljs-keyword">if</span> (e[i].u == u) <span class="hljs-keyword">return</span> e[i].v;<br>    <span class="hljs-keyword">return</span> e[++cnt] = (data)&#123;u, <span class="hljs-number">-1</span>, h[hu]&#125;, h[hu] = cnt, e[cnt].v;<br>  &#125;<br><br>  <span class="hljs-built_in">hash_map</span>() &#123;<br>    cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(h));<br>  &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>并查集是一种用于管理元素所属集合的数据结构，实现为一个森林，其中每棵树表示一个集合，树中的节点表示对应集合中的元素。</p><p>并查集支持两种操作：</p><ul><li>合并（Union）：合并两个元素所属集合（合并对应的树）</li><li>查询（Find）：查询某个元素所属集合（查询对应的树的根节点），这可以用于判断两个元素是否属于同一集合</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UFS</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//初始化并查集,iota实现从0开始的递增序列vector</span><br><span class="hljs-built_in">UFS</span>(gg n) : <span class="hljs-built_in">ufs</span>(n + <span class="hljs-number">5</span>) &#123; <span class="hljs-built_in">iota</span>(<span class="hljs-built_in">begin</span>(ufs), <span class="hljs-built_in">end</span>(ufs), <span class="hljs-number">0</span>); &#125; <span class="hljs-comment">//查找结点所在树的根结点并进行路径压缩</span><br><span class="hljs-function">gg <span class="hljs-title">findRoot</span><span class="hljs-params">(gg x)</span> </span>&#123; <span class="hljs-keyword">return</span> ufs[x] == x ? x : ufs[x] = <span class="hljs-built_in">findRoot</span>(ufs[x]); &#125; <span class="hljs-comment">//合并两个结点所在集合，如果已在同一集合，返回false</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">unionSets</span><span class="hljs-params">(gg a, gg b)</span> </span>&#123;<br>  a = <span class="hljs-built_in">findRoot</span>(a), b = <span class="hljs-built_in">findRoot</span>(b);<br>  <span class="hljs-keyword">if</span> (a == b) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  ufs[a] = b;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span>* fa)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> (x==fa[x])?x:(fa[x]=<span class="hljs-built_in">find</span>(fa[x], fa));<br>&#125;<br>  <span class="hljs-keyword">private</span>:<br>    vector&lt;gg&gt; ufs;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆性质：父亲的权值不小于儿子的权值（大根堆）。同样的，我们可以定义小根堆。本文以大根堆为例。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">while</span> (x &gt; <span class="hljs-number">1</span> &amp;&amp; h[x] &gt; h[x / <span class="hljs-number">2</span>]) &#123;<br>    <span class="hljs-built_in">swap</span>(h[x], h[x / <span class="hljs-number">2</span>]);<br>    x /= <span class="hljs-number">2</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">while</span> (x * <span class="hljs-number">2</span> &lt;= n) &#123;<br>    t = x * <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (t + <span class="hljs-number">1</span> &lt;= n &amp;&amp; h[t + <span class="hljs-number">1</span>] &gt; h[t]) t++;<br>    <span class="hljs-keyword">if</span> (h[t] &lt;= h[x]) <span class="hljs-keyword">break</span>;<br>    std::<span class="hljs-built_in">swap</span>(h[x], h[t]);<br>    x = t;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><p>线段树是算法竞赛中常用的用来维护 <strong>区间信息</strong> 的数据结构。</p><p>线段树可以在 $O(logn)$ 的时间复杂度内实现单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值)等操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-type">int</span> n, a[<span class="hljs-number">100005</span>], d[<span class="hljs-number">270000</span>], b[<span class="hljs-number">270000</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (l == r) &#123;<br>    d[p] = a[l];<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-type">int</span> m = l + ((r - l) &gt;&gt; <span class="hljs-number">1</span>);<br>  <span class="hljs-built_in">build</span>(l, m, p &lt;&lt; <span class="hljs-number">1</span>), <span class="hljs-built_in">build</span>(m + <span class="hljs-number">1</span>, r, (p &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-number">1</span>);<br>  d[p] = d[p &lt;&lt; <span class="hljs-number">1</span>] + d[(p &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t,</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-type">int</span> p)</span> </span>&#123; <br>  <span class="hljs-keyword">if</span> (l &lt;= s &amp;&amp; t &lt;= r) &#123;<br>    d[p] = (t - s + <span class="hljs-number">1</span>) * c, b[p] = c;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-type">int</span> m = s + ((t - s) &gt;&gt; <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">if</span> (b[p]) &#123;<br>    d[p &lt;&lt; <span class="hljs-number">1</span>] = b[p] * (m - s + <span class="hljs-number">1</span>), d[(p &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-number">1</span>] = b[p] * (t - m);<br>    b[p &lt;&lt; <span class="hljs-number">1</span>] = b[(p &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-number">1</span>] = b[p];<br>    b[p] = <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (l &lt;= m) <span class="hljs-built_in">update</span>(l, r, c, s, m, p &lt;&lt; <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">if</span> (r &gt; m) <span class="hljs-built_in">update</span>(l, r, c, m + <span class="hljs-number">1</span>, t, (p &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-number">1</span>);<br>  d[p] = d[p &lt;&lt; <span class="hljs-number">1</span>] + d[(p &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> p)</span> </span>&#123;  <span class="hljs-comment">// 取得答案，和前面一样</span><br>  <span class="hljs-keyword">if</span> (l &lt;= s &amp;&amp; t &lt;= r) <span class="hljs-keyword">return</span> d[p];<br>  <span class="hljs-type">int</span> m = s + ((t - s) &gt;&gt; <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">if</span> (b[p]) &#123;<br>    d[p &lt;&lt; <span class="hljs-number">1</span>] = b[p] * (m - s + <span class="hljs-number">1</span>), d[(p &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-number">1</span>] = b[p] * (t - m);<br>    b[p &lt;&lt; <span class="hljs-number">1</span>] = b[(p &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-number">1</span>] = b[p];<br>    b[p] = <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (l &lt;= m) sum = <span class="hljs-built_in">getsum</span>(l, r, s, m, p &lt;&lt; <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">if</span> (r &gt; m) sum += <span class="hljs-built_in">getsum</span>(l, r, m + <span class="hljs-number">1</span>, t, (p &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>  std::cin &gt;&gt; n;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) std::cin &gt;&gt; a[i];<br>  <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, n, <span class="hljs-number">1</span>);<br>  <span class="hljs-type">int</span> q, i1, i2, i3, i4;<br>  std::cin &gt;&gt; q;<br>  <span class="hljs-keyword">while</span> (q--) &#123;<br>    std::cin &gt;&gt; i1 &gt;&gt; i2 &gt;&gt; i3;<br>    <span class="hljs-keyword">if</span> (i1 == <span class="hljs-number">0</span>)<br>      std::cout &lt;&lt; <span class="hljs-built_in">getsum</span>(i2, i3, <span class="hljs-number">1</span>, n, <span class="hljs-number">1</span>) &lt;&lt; std::endl;<br>    <span class="hljs-keyword">else</span><br>      std::cin &gt;&gt; i4, <span class="hljs-built_in">update</span>(i2, i3, i4, <span class="hljs-number">1</span>, n, <span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>下周把数据结构这部分写完，还剩二叉树内容，只打算补充 Splay 和 Treap</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>OI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>My First Blog</title>
    <link href="/2024/08/12/My-First-Blog/"/>
    <url>/2024/08/12/My-First-Blog/</url>
    
    <content type="html"><![CDATA[<p>This is my first blog</p><span id="more"></span><h1 id="First-Blog"><a href="#First-Blog" class="headerlink" title="First Blog"></a>First Blog</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">using</span> std::cout</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  cout&lt;&lt;<span class="hljs-string">&quot;hello world!&quot;</span>&lt;&lt;endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>helloworld</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
