<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Data Structure</title>
    <link href="/2024/08/13/Data-Structure/"/>
    <url>/2024/08/13/Data-Structure/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><blockquote><p>机考前的临时抱佛脚</p></blockquote><span id="more"></span><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈的修改与访问是按照后进先出的原则进行的，因此栈通常被称为是后进先出（last in first out）表，简称 LIFO 表。</p><h3 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h3><p>C++ 中的 STL 提供了一个容器 <code>std::stack</code>，使用前需要引入 <code>stack</code> 头文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// clang-format off</span><br><span class="hljs-keyword">template</span>&lt;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>,<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span> = std::deque&lt;T&gt;<br>&gt; <span class="hljs-keyword">class</span> stack;<br><span class="hljs-comment">// 新建两个栈 st1 和 st2</span><br>std::stack&lt;<span class="hljs-type">int</span>&gt; st1, st2;<br><span class="hljs-comment">// 为 st1 装入 1</span><br>st<span class="hljs-number">1.</span><span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br><span class="hljs-comment">// 将 st1 赋值给 st2</span><br>st2 = st1;<br><span class="hljs-comment">// 输出 st2 的栈顶元素</span><br>cout &lt;&lt; st<span class="hljs-number">2.</span><span class="hljs-built_in">top</span>() &lt;&lt; endl;<br><span class="hljs-comment">// 输出: 1</span><br></code></pre></td></tr></table></figure><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列（queue）是一种具有「先进入队列的元素一定先出队列」性质的表。由于该性质，队列通常也被称为先进先出（first in first out）表，简称 FIFO 表。</p><h3 id="STL-1"><a href="#STL-1" class="headerlink" title="STL"></a>STL</h3><p>C++ 在 STL 中提供了一个容器 <code>std::queue</code>，使用前需要先引入 <code>queue</code> 头文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::queue&lt;<span class="hljs-type">int</span>&gt; q1, q2;<br><span class="hljs-comment">// 向 q1 的队尾插入 1</span><br>q<span class="hljs-number">1.</span><span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br><span class="hljs-comment">// 将 q1 赋值给 q2</span><br>q2 = q1;<br><span class="hljs-comment">// 输出 q2 的队首元素</span><br>std::cout &lt;&lt; q<span class="hljs-number">2.f</span>ront() &lt;&lt; std::endl;<br><span class="hljs-comment">// 输出: 1</span><br></code></pre></td></tr></table></figure><h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><p>双端队列是指一个可以在队首&#x2F;队尾插入或删除元素的队列。相当于是栈与队列功能的结合。</p><h3 id="STL-2"><a href="#STL-2" class="headerlink" title="STL"></a>STL</h3><p>C++ 在 STL 中也提供了一个容器 <code>std::deque</code>，使用前需要先引入 <code>deque</code> 头文件</p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>哈希表又称散列表，一种以「key-value」形式存储数据的数据结构。所谓以「key-value」形式存储数据，是指任意的键值 key 都唯一对应到内存中的某个位置。只需要输入查找的键值，就可以快速地找到其对应的 value。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">hash_map</span> &#123;  <span class="hljs-comment">// 哈希表模板</span><br><br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">data</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> u;<br>    <span class="hljs-type">int</span> v, nex;<br>  &#125;;  <span class="hljs-comment">// 前向星结构</span><br><br>  data e[SZ &lt;&lt; <span class="hljs-number">1</span>];  <span class="hljs-comment">// SZ 是 const int 表示大小</span><br>  <span class="hljs-type">int</span> h[SZ], cnt;<br><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> u)</span> </span>&#123; <span class="hljs-keyword">return</span> (u % SZ + SZ) % SZ; &#125;<br><br>  <span class="hljs-comment">// 这里使用 (u % SZ + SZ) % SZ 而非 u % SZ 的原因是</span><br>  <span class="hljs-comment">// C++ 中的 % 运算无法将负数转为正数</span><br><br>  <span class="hljs-type">int</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">long</span> <span class="hljs-type">long</span> u) &#123;<br>    <span class="hljs-type">int</span> hu = <span class="hljs-built_in">hash</span>(u);  <span class="hljs-comment">// 获取头指针</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[hu]; i; i = e[i].nex)<br>      <span class="hljs-keyword">if</span> (e[i].u == u) <span class="hljs-keyword">return</span> e[i].v;<br>    <span class="hljs-keyword">return</span> e[++cnt] = (data)&#123;u, <span class="hljs-number">-1</span>, h[hu]&#125;, h[hu] = cnt, e[cnt].v;<br>  &#125;<br><br>  <span class="hljs-built_in">hash_map</span>() &#123;<br>    cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(h));<br>  &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>并查集是一种用于管理元素所属集合的数据结构，实现为一个森林，其中每棵树表示一个集合，树中的节点表示对应集合中的元素。</p><p>并查集支持两种操作：</p><ul><li>合并（Union）：合并两个元素所属集合（合并对应的树）</li><li>查询（Find）：查询某个元素所属集合（查询对应的树的根节点），这可以用于判断两个元素是否属于同一集合</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UFS</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//初始化并查集,iota实现从0开始的递增序列vector</span><br><span class="hljs-built_in">UFS</span>(gg n) : <span class="hljs-built_in">ufs</span>(n + <span class="hljs-number">5</span>) &#123; <span class="hljs-built_in">iota</span>(<span class="hljs-built_in">begin</span>(ufs), <span class="hljs-built_in">end</span>(ufs), <span class="hljs-number">0</span>); &#125; <span class="hljs-comment">//查找结点所在树的根结点并进行路径压缩</span><br><span class="hljs-function">gg <span class="hljs-title">findRoot</span><span class="hljs-params">(gg x)</span> </span>&#123; <span class="hljs-keyword">return</span> ufs[x] == x ? x : ufs[x] = <span class="hljs-built_in">findRoot</span>(ufs[x]); &#125; <span class="hljs-comment">//合并两个结点所在集合，如果已在同一集合，返回false</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">unionSets</span><span class="hljs-params">(gg a, gg b)</span> </span>&#123;<br>  a = <span class="hljs-built_in">findRoot</span>(a), b = <span class="hljs-built_in">findRoot</span>(b);<br>  <span class="hljs-keyword">if</span> (a == b) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  ufs[a] = b;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span>* fa)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> (x==fa[x])?x:(fa[x]=<span class="hljs-built_in">find</span>(fa[x], fa));<br>&#125;<br>  <span class="hljs-keyword">private</span>:<br>    vector&lt;gg&gt; ufs;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆性质：父亲的权值不小于儿子的权值（大根堆）。同样的，我们可以定义小根堆。本文以大根堆为例。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">while</span> (x &gt; <span class="hljs-number">1</span> &amp;&amp; h[x] &gt; h[x / <span class="hljs-number">2</span>]) &#123;<br>    <span class="hljs-built_in">swap</span>(h[x], h[x / <span class="hljs-number">2</span>]);<br>    x /= <span class="hljs-number">2</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">while</span> (x * <span class="hljs-number">2</span> &lt;= n) &#123;<br>    t = x * <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (t + <span class="hljs-number">1</span> &lt;= n &amp;&amp; h[t + <span class="hljs-number">1</span>] &gt; h[t]) t++;<br>    <span class="hljs-keyword">if</span> (h[t] &lt;= h[x]) <span class="hljs-keyword">break</span>;<br>    std::<span class="hljs-built_in">swap</span>(h[x], h[t]);<br>    x = t;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><p>线段树是算法竞赛中常用的用来维护 <strong>区间信息</strong> 的数据结构。</p><p>线段树可以在 $O(logn)$ 的时间复杂度内实现单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值)等操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-type">int</span> n, a[<span class="hljs-number">100005</span>], d[<span class="hljs-number">270000</span>], b[<span class="hljs-number">270000</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> p)</span> </span>&#123;  <span class="hljs-comment">// 建树</span><br>  <span class="hljs-keyword">if</span> (l == r) &#123;<br>    d[p] = a[l];<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-type">int</span> m = l + ((r - l) &gt;&gt; <span class="hljs-number">1</span>);<br>  <span class="hljs-built_in">build</span>(l, m, p &lt;&lt; <span class="hljs-number">1</span>), <span class="hljs-built_in">build</span>(m + <span class="hljs-number">1</span>, r, (p &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-number">1</span>);<br>  d[p] = d[p &lt;&lt; <span class="hljs-number">1</span>] + d[(p &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t,</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-type">int</span> p)</span> </span>&#123;  <span class="hljs-comment">// 更新，可以参考前面两个例题</span><br>  <span class="hljs-keyword">if</span> (l &lt;= s &amp;&amp; t &lt;= r) &#123;<br>    d[p] = (t - s + <span class="hljs-number">1</span>) * c, b[p] = c;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-type">int</span> m = s + ((t - s) &gt;&gt; <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">if</span> (b[p]) &#123;<br>    d[p &lt;&lt; <span class="hljs-number">1</span>] = b[p] * (m - s + <span class="hljs-number">1</span>), d[(p &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-number">1</span>] = b[p] * (t - m);<br>    b[p &lt;&lt; <span class="hljs-number">1</span>] = b[(p &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-number">1</span>] = b[p];<br>    b[p] = <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (l &lt;= m) <span class="hljs-built_in">update</span>(l, r, c, s, m, p &lt;&lt; <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">if</span> (r &gt; m) <span class="hljs-built_in">update</span>(l, r, c, m + <span class="hljs-number">1</span>, t, (p &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-number">1</span>);<br>  d[p] = d[p &lt;&lt; <span class="hljs-number">1</span>] + d[(p &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> p)</span> </span>&#123;  <span class="hljs-comment">// 取得答案，和前面一样</span><br>  <span class="hljs-keyword">if</span> (l &lt;= s &amp;&amp; t &lt;= r) <span class="hljs-keyword">return</span> d[p];<br>  <span class="hljs-type">int</span> m = s + ((t - s) &gt;&gt; <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">if</span> (b[p]) &#123;<br>    d[p &lt;&lt; <span class="hljs-number">1</span>] = b[p] * (m - s + <span class="hljs-number">1</span>), d[(p &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-number">1</span>] = b[p] * (t - m);<br>    b[p &lt;&lt; <span class="hljs-number">1</span>] = b[(p &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-number">1</span>] = b[p];<br>    b[p] = <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (l &lt;= m) sum = <span class="hljs-built_in">getsum</span>(l, r, s, m, p &lt;&lt; <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">if</span> (r &gt; m) sum += <span class="hljs-built_in">getsum</span>(l, r, m + <span class="hljs-number">1</span>, t, (p &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>  std::cin &gt;&gt; n;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) std::cin &gt;&gt; a[i];<br>  <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, n, <span class="hljs-number">1</span>);<br>  <span class="hljs-type">int</span> q, i1, i2, i3, i4;<br>  std::cin &gt;&gt; q;<br>  <span class="hljs-keyword">while</span> (q--) &#123;<br>    std::cin &gt;&gt; i1 &gt;&gt; i2 &gt;&gt; i3;<br>    <span class="hljs-keyword">if</span> (i1 == <span class="hljs-number">0</span>)<br>      std::cout &lt;&lt; <span class="hljs-built_in">getsum</span>(i2, i3, <span class="hljs-number">1</span>, n, <span class="hljs-number">1</span>) &lt;&lt; std::endl;<br>    <span class="hljs-keyword">else</span><br>      std::cin &gt;&gt; i4, <span class="hljs-built_in">update</span>(i2, i3, i4, <span class="hljs-number">1</span>, n, <span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>OI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>My First Blog</title>
    <link href="/2024/08/12/My-First-Blog/"/>
    <url>/2024/08/12/My-First-Blog/</url>
    
    <content type="html"><![CDATA[<p>This is my first blog</p><span id="more"></span><h1 id="First-Blog"><a href="#First-Blog" class="headerlink" title="First Blog"></a>First Blog</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">using</span> std::cout</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  cout&lt;&lt;<span class="hljs-string">&quot;hello world!&quot;</span>&lt;&lt;endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>helloworld</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
