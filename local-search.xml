<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>REQSMINER 论文阅读笔记</title>
    <link href="/2024/11/05/REQSMINER-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/11/05/REQSMINER-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>REQSMINER 论文阅读笔记: NDSS 2024</p><span id="more"></span><h1 id="REQSMINER-论文阅读笔记"><a href="#REQSMINER-论文阅读笔记" class="headerlink" title="REQSMINER 论文阅读笔记"></a>REQSMINER 论文阅读笔记</h1><p>REQSMINER: Automated Discovery of CDN Forwarding Request Inconsistencies and DoS Attacks with Grammar-based Fuzzing</p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><ul><li>CDN 是设计用于提升托管网站性能并保护其免受各种攻击的普遍中间件</li><li>CDN 在将客户端请求转发至原始服务器时会修改该请求，转发操作存在不一致性</li><li>本文提出 REQSMINER，一个基于强化学习技术检测 CDN 转发请求不一致性的模糊测试框架。</li></ul><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>CDN 缓存内容到边缘服务器，显著提高用户访问内容时的响应速度与可用性</p><p>研究发现，CDN在转发请求时的操作不一致可能导致多种安全问题，如拒绝服务和缓存投毒攻击等。然而，现有研究主要依赖手动分析，缺乏系统性方法，且因语法不严、成本高和黑箱操作带来诸多挑战。</p><h3 id="Prior-research"><a href="#Prior-research" class="headerlink" title="Prior research"></a>Prior research</h3><ul><li>CDN 转发请求不一致性会导致诸多攻击：HoT, HRS, DoS, CPDoS</li><li>大多数先前的研究依赖于手动分析，或集中于单一类型的不一致性</li></ul><h3 id="Challenges"><a href="#Challenges" class="headerlink" title="Challenges"></a>Challenges</h3><ul><li>语法宽松：生成的模板中不受约束的 ABNF 规则使得模糊测试难以提供有效值</li><li>成本高昂：由于测试用例庞大，研究 CDN 这样的商业服务代价高昂</li><li>黑箱性：出于商业机密，CDN 的源代码未向公众开放，因此反馈较少</li></ul><h3 id="Our-Contributions"><a href="#Our-Contributions" class="headerlink" title="Our Contributions"></a>Our Contributions</h3><p>本研究提出了 REQSMINER 框架，利用强化学习算法并结合字段值和 ABNF 规则，实现了自动化的 CDN 请求不一致性模糊测试</p><ul><li>从 RFC 文档和实际 HTTP 流量中提取有效值，将其存储为字段值。使用字段值辅助规则融合器，将这些值与 ABNF 规则合并，从而创建 ABNF 语法树作为生成模板</li><li>采用加权随机化的应用树上置信界 (UCT-Rand) 算法来优化模糊测试</li></ul><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>在本节中，我们首先介绍内容分发网络（CDN）的基本概念，简要展示HTTP标准，最后介绍我们采用的技术，包括基于语法的模糊测试和蒙特卡洛树搜索算法。</p><h3 id="CDN-Overview"><a href="#CDN-Overview" class="headerlink" title="CDN Overview"></a>CDN Overview</h3><p>内容分发网络（CDN）是一组地理分布的服务器（节点），它们协同工作以实现互联网内容的快速传输，不仅能提升托管网站的性能，还提供安全保护，包括 Web 应用防火墙和 DDoS（分布式拒绝服务）防御。</p><h4 id="Request-routing-Mechanism"><a href="#Request-routing-Mechanism" class="headerlink" title="Request-routing Mechanism"></a>Request-routing Mechanism</h4><p>请求路由技术决定了网站管理员如何将网站托管在 CDN 上，以下是两种常见的请求路由技术：</p><ul><li>将域名重定向至 CDN 的子域名，这些子域名被映射到全球 CDN 边缘服务器网络</li><li>使用 CDN 的 DNS 服务器作为网站域名的权威名称服务器</li></ul><h4 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h4><p>CDN的架构可以分为两大部分：</p><ul><li>中心节点负责负载均衡和内容管理</li><li>边缘节点则负责缓存和分发内容，包括入口和出口节点。入口节点靠近客户端，处理访问请求，而出口节点则靠近源服务器，负责转发请求。</li></ul><h4 id="Workflows"><a href="#Workflows" class="headerlink" title="Workflows"></a>Workflows</h4><ul><li>在接收到客户端请求后，CDN首先检查缓存中是否有对应的数据。</li><li>如果缓存缺失，CDN会将请求转发至源服务器以获取所需资源，并将响应缓存以供后续请求使用。这些查询通常被称为“回源”请求。</li><li>通过负载均衡，CDN动态选择入口和出口节点，并尝试利用缓存以减少源服务器的负担。</li></ul><h3 id="HTTP-Standard"><a href="#HTTP-Standard" class="headerlink" title="HTTP Standard"></a>HTTP Standard</h3><p>超文本传输协议（HTTP）的标准主要由 RFC 9110 制定，并具有 ABNF 规则定义的标准化协议元素格式。</p><h4 id="ABNF-Rules"><a href="#ABNF-Rules" class="headerlink" title="ABNF Rules"></a>ABNF Rules</h4><p>增强的巴科斯-瑙尔范式（ABNF）是一种上下文无关文法（CFG）语法 ，如下图所示：</p><p><img src="/img/REQSMINER/figure-1.png" alt="ABNF Rules"></p><h4 id="HTTP-Header-Fields"><a href="#HTTP-Header-Fields" class="headerlink" title="HTTP Header Fields"></a>HTTP Header Fields</h4><p>HTTP使用字段在内容之前提供特定的头部数据，这些字段称为头字段。头字段的格式为 name 对。HTTP头部，如“Host.com”，由不区分大小写的名称、冒号（“:”）及其值组成。</p><h3 id="Grammar-based-Fuzzing"><a href="#Grammar-based-Fuzzing" class="headerlink" title="Grammar-based Fuzzing"></a>Grammar-based Fuzzing</h3><p>语法化模糊测试是识别软件系统中潜在漏洞的最常用测试技术之一。该方法使用一组预定义的规则或“语法”来生成测试输入。</p><h3 id="Monte-Carlo-Tree-Search"><a href="#Monte-Carlo-Tree-Search" class="headerlink" title="Monte Carlo Tree Search"></a>Monte Carlo Tree Search</h3><p>蒙特卡洛树搜索（MCTS）是一种启发式搜索算法，它通过模拟来探索潜在的行动并选择最有前景的行动。</p><p>MCTS的执行过程分为四个阶段：选择（Selection）、扩展（Expansion）、模拟（Simulation）和反向传播（Backpropagation）</p><h4 id="UCT"><a href="#UCT" class="headerlink" title="UCT"></a>UCT</h4><p>Upper Confidence Bounds Applied to Trees</p><p>UCT 是 MCTS 的一种变体，旨在平衡游戏 AI 中的探索和利用。UCT 利用上置信界（UCB）公式，这个公式结合了当前节点的价值估计和探索参数，以选择最有前景的节点进行扩展。</p><p>UCB 公式如下：<br><img src="/img/REQSMINER/figure-2.png" alt="UCB"></p><h2 id="REQSMINER-Design"><a href="#REQSMINER-Design" class="headerlink" title="REQSMINER Design"></a>REQSMINER Design</h2><p>REQSMINER的设计框架包括以下关键组成部分：</p><ol><li>规则生成器：该组件用于定义和生成有效的请求规则，以确保生成的请求符合CDN的语法和结构要求。规则生成器能够从已知的有效请求中提取模式和特征，帮助生成新的测试请求。</li><li>基于语法的模糊测试：利用预定义的语法规则生成多样化的测试输入，系统地覆盖不同的请求参数组合。通过对请求进行有针对性的变异，模糊测试能够有效识别潜在的安全漏洞。</li></ol><h3 id="Threat-Model"><a href="#Threat-Model" class="headerlink" title="Threat Model"></a>Threat Model</h3><p>威胁模型如下：</p><p><img src="/img/REQSMINER/figure-3.png" alt="Threat Model"></p><ul><li><p>攻击者伪装成合法客户，能够向存在缺陷的 CDN 发送精心构造的请求，CDN随后会修改并转发这些请求。</p></li><li><p>目标网站作为攻击者的目标托管在 CDN 上，或者在不知情的情况下由攻击者托管。</p></li><li><p>在这些假设下，攻击者可以利用特定的 CDN 转发请求差异在 CDN 与源服务器之间的连接中操纵请求。通过这些恶意请求，可能会对受害的源服务器执行多种攻击：DoS、CPDoS、FL 和 WCP。</p></li></ul><h3 id="REQSMINER-Overview"><a href="#REQSMINER-Overview" class="headerlink" title="REQSMINER Overview"></a>REQSMINER Overview</h3><p>REQSMINER 的设计框架如下：  </p><p><img src="/img/REQSMINER/figure-4.png" alt="REQSMINER Overview"></p><h4 id="Rule-Generator"><a href="#Rule-Generator" class="headerlink" title="Rule Generator"></a>Rule Generator</h4><p>利用字段值限制 ABNF 规则的搜索空间，通过将 ABNF 规则与字段值结合，生成 ABNF 语法树。具体来说，字段值是符合 RFC 的预定义数据，以键值对的形式存储，提取自 RFC 及实际网络流量。关键在于将专家领域知识融入生成规则中，从而提高生成效率。</p><h4 id="Grammar-based-Fuzzing-1"><a href="#Grammar-based-Fuzzing-1" class="headerlink" title="Grammar-based Fuzzing"></a>Grammar-based Fuzzing</h4><p>UCT 基于请求生成器使用 ABNF 语法树生成 HTTP 测试请求，并通过客户端将其发送到 CDN。这里的客户端和 CDN 后面的服务器均在 REQSMINER 的控制之下。在从服务器获取 CDN 的转发状态后，更新 ABNF 语法树中每个分支的生成算法参数。同时，差异分析器收集客户端和服务器端的日志，包括客户端发送的原始请求和服务器接收到的转发请求，并比较这些日志以发现转发请求的任何变化。</p><h3 id="Rule-Generator-1"><a href="#Rule-Generator-1" class="headerlink" title="Rule Generator"></a>Rule Generator</h3><p>ABNF 解析器创建三种类型的 ABNF 语法树节点，包括 AND、OR 和 RAND。</p><ul><li>AND节点：作为串联和唯一重复的操作符，AND节点在ABNF语法树中表示串联。访问这些节点时，所有子节点必须递归选择以继续生成。</li><li>OR节点：表示选择，代表替代和有限重复操作符。访问这些节点时，任何子节点都必须递归访问。</li><li>RAND节点：对应于ABNF语法中的无限重复操作符，RAND节点标记为随机，这意味着子节点的访问次数是随机的。</li></ul><p>下图展示了一个简单的 ABNF 语法树：</p><p><img src="/img/REQSMINER/figure-5.png" alt="ABNF Tree"></p><h3 id="Rule-Fusioner"><a href="#Rule-Fusioner" class="headerlink" title="Rule Fusioner"></a>Rule Fusioner</h3><p>规则融合器通过将字段值解析为非终结符值并将其插入到ABNF语法树中，从而增强了生成有效测试用例的能力。</p><p>例如，对于字段值“Accept-Language: en-US,en;q&#x3D;0.9,en-GB;q&#x3D;0.8,zh;q&#x3D;0.7,ja”，该值包含多种语言范围。在使用ABNF规则（见列表1，第6行）解析后，融合器可以提取多个语言范围值（例如，en-US、en、en-GB、zh和ja）。这样做是为了增加模糊测试器生成有效值的可能性，例如en-US、en和zh。</p><p>如下图所示：</p><p><img src="/img/REQSMINER/figure-6.png" alt="Rule Fusioner"></p><h3 id="Grammar-based-Fuzzing-2"><a href="#Grammar-based-Fuzzing-2" class="headerlink" title="Grammar-based Fuzzing"></a>Grammar-based Fuzzing</h3><p>REQSMINER 使用请求生成器（Request Generator）来生成更多有效的测试用例，并对CDN进行基于语法的模糊测试，以有效识别请求差异和潜在漏洞。</p><h4 id="Request-Generator"><a href="#Request-Generator" class="headerlink" title="Request Generator"></a>Request Generator</h4><p>为了使 REQSMINER 具有优越的有效性和探索能力，受蒙特卡洛树搜索（MCTS）算法启发，我们提出了一种基于 UCT 的加权随机生成算法（UCT-Rand）。与 UCT 不同，UCT-Rand 在选择阶段使用加权随机选择，而不是使用 argmax 函数来选择下一个子节点。</p><p>如果当前节点是一个具有未访问子节点的 OR 节点，则随机选择一个子节点进行扩展遍历。</p><p>如果当前节点的所有子节点在先前的迭代中都已被探索，表示该节点的搜索已完成，则使用UCB公式来确定所有子节点的权重：</p><p><img src="/img/REQSMINER/figure-7.png" alt="UCT-Rand"></p><h4 id="Courier-Platform"><a href="#Courier-Platform" class="headerlink" title="Courier Platform"></a>Courier Platform</h4><ul><li>由客户端、服务器和进行测试的目标 CDN 组成。</li><li>客户端向目标 CDN 发送测试请求，这些请求随后被 CDN 转发到服务器。</li><li>所有请求都会被记录并发送到差异分析器。</li><li>此外，服务器从 CDN 接收请求，并针对 CDN 发送与请求无关的 HTTP 响应。</li><li>服务器会记录来自 CDN 的转发请求，并将其发送给差异分析器。</li><li>服务器还向请求生成器提供日志，指示 CDN 已成功转发该请求。</li></ul><h4 id="Difference-Analyzer"><a href="#Difference-Analyzer" class="headerlink" title="Difference Analyzer"></a>Difference Analyzer</h4><p>差异分析器负责通过进行比较分析来检测 CDN 在转发请求时所做的修改。具体来说，它使用简化的 ABNF 规则提取原始请求和转发请求的请求结构。通过对这些结构的比较，差异分析器揭示了 CDN 对请求所实施的各种修改类型，包括：</p><ul><li>修改（Alteration）：CDN修改了原始请求的头部值。</li><li>插入（Insertion）：CDN添加了原始请求中不存在的头部。</li><li>删除（Deletion）：CDN从原始请求中移除了某个头部。</li><li>重复头部插入（Duplicate Header Insertion）：CDN 添加了原始请求中已经存在的头部。</li><li>重复头部删除（Duplicate Header Deletion）：CDN 移除了原始请求中的重复头部。</li></ul><p>最终，这些各种类型的修改会被存档到数据库中，以便在后续研究中使用。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Paper Reading</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2024.10.17-Update</title>
    <link href="/2024/10/17/2024-10-17-Update/"/>
    <url>/2024/10/17/2024-10-17-Update/</url>
    
    <content type="html"><![CDATA[<p>更新一下近期状态吧，最近在学习的东西有点多，有点乱，总结一下。</p><span id="more"></span><h1 id="Status-Update"><a href="#Status-Update" class="headerlink" title="Status Update"></a>Status Update</h1><h2 id="协议-Fuzzing"><a href="#协议-Fuzzing" class="headerlink" title="协议 Fuzzing"></a>协议 Fuzzing</h2><p>打算入门协议 Fuzzing 作为未来的研究方向，目前正在学习相关知识。从综述开始读起，对 Fuzzing<br>先有一个大概了解，同时找到了一个不错的 <a href="https://wcventure.github.io/FuzzingPaper/">Fuzzing 论文总结网站</a> ，先存着留着后面用（bushi </p><h2 id="CTF-入门"><a href="#CTF-入门" class="headerlink" title="CTF 入门"></a>CTF 入门</h2><p>正在读 《从 0 到 1》 这本书，#沉淀，同时看到 THU 网安协会的一个入门的学习资源：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">另外以下是我们以前简单列的 <span class="hljs-built_in">CTF</span> 学习资源，仅作参考~ 之后可能会添加一些内容<br><br><span class="hljs-built_in">CTF</span> 基础入门：ctf-wiki.org（各个方向）、星盟安全 Pwn 公开课（https:<span class="hljs-comment">//b23.tv/KOZeFNL）、pwnable.kr（Pwn 方向做题）；</span><br>刷题平台：<span class="hljs-built_in">XCTF</span> 攻防世界、bugku、BUUOJ；<br>工具推荐：<br> <span class="hljs-number">1</span>) Pwn：IDA Pro、pwntools、pwndbg；<br> <span class="hljs-number">2</span>) Web：BurpSuite、SQLMap 等；<br>书籍推荐：《从<span class="hljs-number">0</span>到<span class="hljs-number">1</span>-<span class="hljs-built_in">CTFer</span>成长之路》、《<span class="hljs-built_in">CTF</span>特训营》等（时间较多的话选一本入门即可）。<br></code></pre></td></tr></table></figure><p>近期先好好学 Web， 包会网络安全的呀（bushi</p><h2 id="网络原理"><a href="#网络原理" class="headerlink" title="网络原理"></a>网络原理</h2><ol><li>当了这学期的网原助教，学了下 Stanford 的 CS144 课程，后续可能会更新这个（？</li><li>课程下学期要更新实验，打算引入 <code>P4 交换机</code> 相关的内容，最近可以玩玩交换机。</li></ol><p>持续更新中…</p>]]></content>
    
    
    
    <tags>
      
      <tag>Status Update</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DDos 攻击</title>
    <link href="/2024/09/11/DDos-%E6%94%BB%E5%87%BB/"/>
    <url>/2024/09/11/DDos-%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="DDos-攻击"><a href="#DDos-攻击" class="headerlink" title="DDos 攻击"></a>DDos 攻击</h1><blockquote><p>最近阅读了一篇关于发表在 Usenix Security 24 上的有关 DDos 攻击防御的论文，借此机会总结一下 DDos 攻击的相关知识。</p></blockquote><span id="more"></span><h2 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h2><p>DDos （Distributed Denial of Service）攻击是一种通过向目标服务器发送大量请求，使其无法正常处理合法请求的攻击方式:  </p><ul><li>攻击者通过控制大量僵尸主机，向目标服务器发送大量请求，使目标机器停止提供服务或资源访问</li><li>资源包括磁盘空间、内存、进程甚至网络带宽</li></ul><p>DDoS 攻击主要利用“僵尸网络”对 TCP 三次握手过程中第一次握手（SYN）和第二次握手（SYN-ACK）步骤来发起攻击。下面介绍两种常见的攻击： SYN Flood 和 ACK Flood。</p><ul><li>SYN Flood 攻击：攻击者发送大量 SYN 请求，但不进行后续的第二次握手（SYN-ACK）和第三次握手（ACK）。这导致服务器资源被大量消耗，因为服务器会为每个 SYN 请求保留资源，等待确认。当大量的SYN请求堆积在服务器上，服务器的处理能力将被严重削弱，无法处理正常的请求。</li><li>ACK Flood 攻击：攻击者发送大量 ACK 请求，但不进行第一次握手（SYN）。这使得服务器在收到ACK请求时，无法找到匹配的 SYN 请求，从而消耗服务器的处理资源。服务器在收到大量无用的 ACK 数据包时，无法正常响应其他请求。</li></ul><h2 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h2><h3 id="SYN-Cookies"><a href="#SYN-Cookies" class="headerlink" title="SYN Cookies"></a>SYN Cookies</h3><p>TCP 服务器收到 SYN 包后，在发送 SYN + ACK 包前，服务器要先分配好一个数据区专门服务于这个即将形成的 TCP 连接。一般把收到 SYN 包而还未收到 ACK 包时的连接状态称为半打开连接(Half-open Connection) 。<br>攻击者通过伪造 IP 地址，向服务器发送大量的 SYN 包，服务器会为每个 SYN 包分配一个数据区，但是不会收到 ACK 包，这样服务器的资源就会被耗尽。</p><p>SYN Cookie 是对 TCP 服务器端的三次握手做一些修改，它的原理是：</p><ul><li>在TCP服务器接收到 SYN 包并返回 SYN + ACK 包时，不分配一个专门的数据区，而是根据这个 SYN 包计算出一个 cookie 值。</li><li>这个 cookie 作为将要返回的 SYN ACK 包的初始序列号。当客户端返回一个 ACK 包时，根据包头信息计算 cookie，与返回的确认序列号(初始序列号 + 1)进行对比，如果相同，则是一个正常连接，然后，分配资源，建立连接。</li></ul><h4 id="Cookie-的生成"><a href="#Cookie-的生成" class="headerlink" title="Cookie 的生成"></a>Cookie 的生成</h4><blockquote><p>cookie的计算应该包含本次连接的状态信息，使攻击者不能伪造</p></blockquote><p>服务器收到一个 SYN 包，计算一个消息摘要 Mac<br>$$<br>mac &#x3D; MAC(A, k)<br>$$<br>在 Linux 中，MAC 为 SHA1，A 为 TCP SYN 包的部分字段，k 为服务器的密钥。<br>$$<br>A &#x3D; SOURCE_IP || SOURCE_PORT || DST_IP || DST_PORT || t || MSSIND<br>$$</p><h4 id="SYN-Cookie-的缺点"><a href="#SYN-Cookie-的缺点" class="headerlink" title="SYN Cookie 的缺点"></a>SYN Cookie 的缺点</h4><ul><li>MSS 的编码只有 3 位，因此最多只能使用 8 种 MSS 值</li><li>服务器必须拒绝客户端 SYN 报文中的其他只在 SYN 和 SYN+ACK 中协商的选项，原因是服务器没有地方可以保存这些选项，比如 Wscale 和 SACK 增加了密码学运算</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>网安</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DP</title>
    <link href="/2024/09/06/DP/"/>
    <url>/2024/09/06/DP/</url>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><blockquote><p>DP 问题</p></blockquote><span id="more"></span><h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><p>记忆化搜索是一种通过记录已经遍历过的状态的信息，从而避免对同一状态重复遍历的搜索实现方式。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ol><li>把这道题的 dp 状态和方程写出来</li><li>根据它们写出 dfs 函数</li><li>添加记忆化数组</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> MMAX = <span class="hljs-number">100</span>;<br><span class="hljs-type">int</span> tcost[MMAX + <span class="hljs-number">10</span>];<br><span class="hljs-type">int</span> mget[MMAX + <span class="hljs-number">10</span>];<br><span class="hljs-type">int</span> mem[MMAX + <span class="hljs-number">5</span>][<span class="hljs-number">1000</span> + <span class="hljs-number">5</span>];<br><span class="hljs-type">int</span> t, n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> tleft)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (mem[pos][tleft] != <span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">return</span> mem[pos][tleft];<br>    <span class="hljs-keyword">if</span> (pos == n + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> mem[pos][tleft] = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> dfs1, dfs2 = <span class="hljs-number">-0x80000000</span>;<br>    dfs1 = <span class="hljs-built_in">dfs</span>(pos + <span class="hljs-number">1</span>, tleft);<br>    <span class="hljs-keyword">if</span> (tleft &gt;= tcost[pos])<br>        dfs2 = <span class="hljs-built_in">dfs</span>(pos + <span class="hljs-number">1</span>, tleft - tcost[pos]) + mget[pos];<br>    <span class="hljs-keyword">return</span> mem[pos][tleft] = <span class="hljs-built_in">max</span>(dfs1, dfs2);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(mem, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(mem));<br>    cin &gt;&gt; t &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        cin &gt;&gt; tcost[i] &gt;&gt; mget[i];<br>    cout &lt;&lt; <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, t) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="背包-DP"><a href="#背包-DP" class="headerlink" title="背包 DP"></a>背包 DP</h2><h3 id="01-背包问题"><a href="#01-背包问题" class="headerlink" title="01 背包问题"></a>01 背包问题</h3><p>状态转移方程如下<br>$$<br>f[j] &#x3D; \max(f[j], f[j - w[i]] + v[i])<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> N, M;<br><span class="hljs-type">int</span> tcost[NMAX + <span class="hljs-number">5</span>];<br><span class="hljs-type">int</span> mget[NMAX + <span class="hljs-number">5</span>];<br><span class="hljs-type">int</span> ans[MMAX + <span class="hljs-number">5</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; N &gt;&gt; M;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++)<br>        cin &gt;&gt; tcost[i] &gt;&gt; mget[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = M; j &gt;= tcost[i]; j--)<br>            ans[j] = <span class="hljs-built_in">max</span>(ans[j - tcost[i]] + mget[i], ans[j]);<br>    &#125;<br>    cout &lt;&lt; ans[M] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h3><p>完全背包模型与 0-1 背包类似，与 0-1 背包的区别仅在于一个物品可以选取无限次，而非仅能选取一次。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> tcost[MMAX + <span class="hljs-number">5</span>];<br><span class="hljs-type">int</span> mget[MMAX + <span class="hljs-number">5</span>];<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> ans[TMAX + <span class="hljs-number">5</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; t &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>        cin &gt;&gt; tcost[i] &gt;&gt; mget[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = tcost[i]; j &lt;= t; j++)<br>            ans[j] = <span class="hljs-built_in">max</span>(ans[j - tcost[i]] + mget[i], ans[j]);<br>    &#125;<br>    cout &lt;&lt; ans[t] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h3><p>多重背包问题是 0-1 背包问题的一个变种，与 0-1 背包的区别在于每种物品的数量不再是 1 个，而是有限个。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> weight = W; weight &gt;= w[i]; weight--) &#123;<br>    <span class="hljs-comment">// 多遍历一层物品数量</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k * w[i] &lt;= weight &amp;&amp; k &lt;= cnt[i]; k++) &#123;<br>      dp[weight] = <span class="hljs-built_in">max</span>(dp[weight], dp[weight - k * w[i]] + k * v[i]);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="混合背包问题"><a href="#混合背包问题" class="headerlink" title="混合背包问题"></a>混合背包问题</h3><p>混合背包就是将前面三种的背包问题混合起来，有的只能取一次，有的能取无限次，有的只能取 k 次。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">for (循环物品种类) &#123;<br>  if (是 0 - 1 背包)<br>    套用 0 - 1 背包代码;<br>  else if (是完全背包)<br>    套用完全背包代码;<br>  else if (是多重背包)<br>    套用多重背包代码;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二维背包问题"><a href="#二维背包问题" class="headerlink" title="二维背包问题"></a>二维背包问题</h3><p>0-1 背包问题，可是不同的是选一个物品会消耗两种价值（经费、时间），只需在状态中增加一维存放第二种价值即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k++)<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = m; i &gt;= mi; i--)    <span class="hljs-comment">// 对经费进行一层枚举</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = t; j &gt;= ti; j--)  <span class="hljs-comment">// 对时间进行一层枚举</span><br>      dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[i - mi][j - ti] + <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h3 id="分组背包问题"><a href="#分组背包问题" class="headerlink" title="分组背包问题"></a>分组背包问题</h3><p>从「在所有物品中选择一件」变成了「从当前组中选择一件」，于是就对每一组进行一次 0-1 背包就可以了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= ts; k++)          <span class="hljs-comment">// 循环每一组</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = m; i &gt;= <span class="hljs-number">0</span>; i--)         <span class="hljs-comment">// 循环背包容量</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= cnt[k]; j++)  <span class="hljs-comment">// 循环该组的每一个物品</span><br>      <span class="hljs-keyword">if</span> (i &gt;= w[t[k][j]])             <span class="hljs-comment">// 背包容量充足</span><br>        dp[i] = <span class="hljs-built_in">max</span>(dp[i],<br>                    dp[i - w[t[k][j]]] + c[t[k][j]]);  <span class="hljs-comment">// 像0-1背包一样状态转移</span><br></code></pre></td></tr></table></figure><h3 id="背包的第-k-优解"><a href="#背包的第-k-优解" class="headerlink" title="背包的第 k 优解"></a>背包的第 k 优解</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(dp));<br><span class="hljs-type">int</span> i, j, p, x, y, z;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;K);<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;w[i]);<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;c[i]);<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>  <span class="hljs-keyword">for</span> (j = m; j &gt;= c[i]; j--) &#123;<br>    <span class="hljs-keyword">for</span> (p = <span class="hljs-number">1</span>; p &lt;= K; p++) &#123;<br>      a[p] = dp[j - c[i]][p] + w[i];<br>      b[p] = dp[j][p];<br>    &#125;<br>    a[p] = b[p] = <span class="hljs-number">-1</span>;<br>    x = y = z = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (z &lt;= K &amp;&amp; (a[x] != <span class="hljs-number">-1</span> || b[y] != <span class="hljs-number">-1</span>)) &#123;<br>      <span class="hljs-keyword">if</span> (a[x] &gt; b[y])<br>        dp[j][z] = a[x++];<br>      <span class="hljs-keyword">else</span><br>        dp[j][z] = b[y++];<br>      <span class="hljs-keyword">if</span> (dp[j][z] != dp[j][z - <span class="hljs-number">1</span>]) z++;<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, dp[m][K]);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>OI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Algorithm</title>
    <link href="/2024/08/16/Algorithm/"/>
    <url>/2024/08/16/Algorithm/</url>
    
    <content type="html"><![CDATA[<h1 id="图论算法"><a href="#图论算法" class="headerlink" title="图论算法"></a>图论算法</h1><blockquote><p>机考前的临时抱佛脚</p></blockquote><span id="more"></span><h2 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h2><h3 id="直接存边"><a href="#直接存边" class="headerlink" title="直接存边"></a>直接存边</h3><p>使用一个数组来存边，数组中的每个元素都包含一条边的起点与终点（带边权的图还包含边权）。（或者使用多个数组分别存起点，终点和边权。）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<br>  <span class="hljs-type">int</span> u, v;<br>&#125;;<br><br><span class="hljs-type">int</span> n, m;<br>vector&lt;Edge&gt; e;<br>vector&lt;<span class="hljs-type">bool</span>&gt; vis;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find_edge</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (e[i].u == u &amp;&amp; e[i].v == v) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  cin &gt;&gt; n &gt;&gt; m;<br>  vis.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>);<br>  e.<span class="hljs-built_in">resize</span>(m + <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) cin &gt;&gt; e[i].u &gt;&gt; e[i].v;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>使用一个二维数组 adj 来存边，其中 adj[u][v] 为 1 表示存在 u 到 v 的边，为 0 表示不存在。如果是带边权的图，可以在 adj[u][v] 中存储 u 到 v 的边的边权。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, m;<br>vector&lt;<span class="hljs-type">bool</span>&gt; vis;<br>vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt; &gt; adj;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find_edge</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123; <span class="hljs-keyword">return</span> adj[u][v]; &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  cin &gt;&gt; n &gt;&gt; m;<br>  vis.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>);<br>  adj.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>));<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>    <span class="hljs-type">int</span> u, v;<br>    cin &gt;&gt; u &gt;&gt; v;<br>    adj[u][v] = <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n, m;<br>vector&lt;<span class="hljs-type">bool</span>&gt; vis;<br>vector&lt;<span class="hljs-type">int</span>&gt; head, nxt, to;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>  nxt.<span class="hljs-built_in">push_back</span>(head[u]);<br>  head[u] = to.<span class="hljs-built_in">size</span>();<br>  to.<span class="hljs-built_in">push_back</span>(v);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find_edge</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = head[u]; ~i; i = nxt[i]) &#123;  <span class="hljs-comment">// ~i 表示 i != -1</span><br>    <span class="hljs-keyword">if</span> (to[i] == v) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (vis[u]) <span class="hljs-keyword">return</span>;<br>  vis[u] = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = head[u]; ~i; i = nxt[i]) <span class="hljs-built_in">dfs</span>(to[i]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  cin &gt;&gt; n &gt;&gt; m;<br><br>  vis.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>);<br>  head.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>    <span class="hljs-type">int</span> u, v;<br>    cin &gt;&gt; u &gt;&gt; v;<br>    <span class="hljs-built_in">add</span>(u, v);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="图搜索算法"><a href="#图搜索算法" class="headerlink" title="图搜索算法"></a>图搜索算法</h2><h3 id="深度优先搜索（DFS）"><a href="#深度优先搜索（DFS）" class="headerlink" title="深度优先搜索（DFS）"></a>深度优先搜索（DFS）</h3><p>DFS 的栈实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; adj;  <span class="hljs-comment">// 邻接表</span><br>vector&lt;<span class="hljs-type">bool</span>&gt; vis;         <span class="hljs-comment">// 记录节点是否已经遍历</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> </span>&#123;<br>  stack&lt;<span class="hljs-type">int</span>&gt; st;<br>  st.<span class="hljs-built_in">push</span>(s);<br>  vis[s] = <span class="hljs-literal">true</span>;<br><br>  <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>    <span class="hljs-type">int</span> u = st.<span class="hljs-built_in">top</span>();<br>    st.<span class="hljs-built_in">pop</span>();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : adj[u]) &#123;<br>      <span class="hljs-keyword">if</span> (!vis[v]) &#123;<br>        vis[v] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 确保栈里没有重复元素</span><br>        st.<span class="hljs-built_in">push</span>(v);<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="广度优先搜索（BFS）"><a href="#广度优先搜索（BFS）" class="headerlink" title="广度优先搜索（BFS）"></a>广度优先搜索（BFS）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>  <span class="hljs-keyword">while</span> (!Q.<span class="hljs-built_in">empty</span>()) Q.<span class="hljs-built_in">pop</span>();<br>  Q.<span class="hljs-built_in">push</span>(u);<br>  vis[u] = <span class="hljs-number">1</span>;<br>  d[u] = <span class="hljs-number">0</span>;<br>  p[u] = <span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">while</span> (!Q.<span class="hljs-built_in">empty</span>()) &#123;<br>    u = Q.<span class="hljs-built_in">front</span>();<br>    Q.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = head[u]; i; i = e[i].nxt) &#123;<br>      <span class="hljs-keyword">if</span> (!vis[e[i].to]) &#123;<br>        Q.<span class="hljs-built_in">push</span>(e[i].to);<br>        vis[e[i].to] = <span class="hljs-number">1</span>;<br>        d[e[i].to] = d[u] + <span class="hljs-number">1</span>;<br>        p[e[i].to] = u;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">restore</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>  vector&lt;<span class="hljs-type">int</span>&gt; res;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v = x; v != <span class="hljs-number">-1</span>; v = p[v]) &#123;<br>    res.<span class="hljs-built_in">push_back</span>(v);<br>  &#125;<br>  std::<span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; res.<span class="hljs-built_in">size</span>(); ++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, res[i]);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>OI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data Structure</title>
    <link href="/2024/08/13/Data-Structure/"/>
    <url>/2024/08/13/Data-Structure/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><blockquote><p>机考前的临时抱佛脚</p></blockquote><span id="more"></span><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈的修改与访问是按照后进先出的原则进行的，因此栈通常被称为是后进先出（last in first out）表，简称 LIFO 表。</p><h3 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h3><p>C++ 中的 STL 提供了一个容器 <code>std::stack</code>，使用前需要引入 <code>stack</code> 头文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// clang-format off</span><br><span class="hljs-keyword">template</span>&lt;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>,<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span> = std::deque&lt;T&gt;<br>&gt; <span class="hljs-keyword">class</span> stack;<br><span class="hljs-comment">// 新建两个栈 st1 和 st2</span><br>std::stack&lt;<span class="hljs-type">int</span>&gt; st1, st2;<br><span class="hljs-comment">// 为 st1 装入 1</span><br>st<span class="hljs-number">1.</span><span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br><span class="hljs-comment">// 将 st1 赋值给 st2</span><br>st2 = st1;<br><span class="hljs-comment">// 输出 st2 的栈顶元素</span><br>cout &lt;&lt; st<span class="hljs-number">2.</span><span class="hljs-built_in">top</span>() &lt;&lt; endl;<br><span class="hljs-comment">// 输出: 1</span><br></code></pre></td></tr></table></figure><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列（queue）是一种具有「先进入队列的元素一定先出队列」性质的表。由于该性质，队列通常也被称为先进先出（first in first out）表，简称 FIFO 表。</p><h3 id="STL-1"><a href="#STL-1" class="headerlink" title="STL"></a>STL</h3><p>C++ 在 STL 中提供了一个容器 <code>std::queue</code>，使用前需要先引入 <code>queue</code> 头文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::queue&lt;<span class="hljs-type">int</span>&gt; q1, q2;<br><span class="hljs-comment">// 向 q1 的队尾插入 1</span><br>q<span class="hljs-number">1.</span><span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br><span class="hljs-comment">// 将 q1 赋值给 q2</span><br>q2 = q1;<br><span class="hljs-comment">// 输出 q2 的队首元素</span><br>std::cout &lt;&lt; q<span class="hljs-number">2.f</span>ront() &lt;&lt; std::endl;<br><span class="hljs-comment">// 输出: 1</span><br></code></pre></td></tr></table></figure><h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><p>双端队列是指一个可以在队首&#x2F;队尾插入或删除元素的队列。相当于是栈与队列功能的结合。</p><h3 id="STL-2"><a href="#STL-2" class="headerlink" title="STL"></a>STL</h3><p>C++ 在 STL 中也提供了一个容器 <code>std::deque</code>，使用前需要先引入 <code>deque</code> 头文件</p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>哈希表又称散列表，一种以「key-value」形式存储数据的数据结构。所谓以「key-value」形式存储数据，是指任意的键值 key 都唯一对应到内存中的某个位置。只需要输入查找的键值，就可以快速地找到其对应的 value。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">hash_map</span> &#123;  <span class="hljs-comment">// 哈希表模板</span><br><br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">data</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> u;<br>    <span class="hljs-type">int</span> v, nex;<br>  &#125;;  <span class="hljs-comment">// 前向星结构</span><br><br>  data e[SZ &lt;&lt; <span class="hljs-number">1</span>];  <span class="hljs-comment">// SZ 是 const int 表示大小</span><br>  <span class="hljs-type">int</span> h[SZ], cnt;<br><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> u)</span> </span>&#123; <span class="hljs-keyword">return</span> (u % SZ + SZ) % SZ; &#125;<br><br>  <span class="hljs-comment">// 这里使用 (u % SZ + SZ) % SZ 而非 u % SZ 的原因是</span><br>  <span class="hljs-comment">// C++ 中的 % 运算无法将负数转为正数</span><br><br>  <span class="hljs-type">int</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">long</span> <span class="hljs-type">long</span> u) &#123;<br>    <span class="hljs-type">int</span> hu = <span class="hljs-built_in">hash</span>(u);  <span class="hljs-comment">// 获取头指针</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[hu]; i; i = e[i].nex)<br>      <span class="hljs-keyword">if</span> (e[i].u == u) <span class="hljs-keyword">return</span> e[i].v;<br>    <span class="hljs-keyword">return</span> e[++cnt] = (data)&#123;u, <span class="hljs-number">-1</span>, h[hu]&#125;, h[hu] = cnt, e[cnt].v;<br>  &#125;<br><br>  <span class="hljs-built_in">hash_map</span>() &#123;<br>    cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(h));<br>  &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>并查集是一种用于管理元素所属集合的数据结构，实现为一个森林，其中每棵树表示一个集合，树中的节点表示对应集合中的元素。</p><p>并查集支持两种操作：</p><ul><li>合并（Union）：合并两个元素所属集合（合并对应的树）</li><li>查询（Find）：查询某个元素所属集合（查询对应的树的根节点），这可以用于判断两个元素是否属于同一集合</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UFS</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//初始化并查集,iota实现从0开始的递增序列vector</span><br><span class="hljs-built_in">UFS</span>(gg n) : <span class="hljs-built_in">ufs</span>(n + <span class="hljs-number">5</span>) &#123; <span class="hljs-built_in">iota</span>(<span class="hljs-built_in">begin</span>(ufs), <span class="hljs-built_in">end</span>(ufs), <span class="hljs-number">0</span>); &#125; <span class="hljs-comment">//查找结点所在树的根结点并进行路径压缩</span><br><span class="hljs-function">gg <span class="hljs-title">findRoot</span><span class="hljs-params">(gg x)</span> </span>&#123; <span class="hljs-keyword">return</span> ufs[x] == x ? x : ufs[x] = <span class="hljs-built_in">findRoot</span>(ufs[x]); &#125; <span class="hljs-comment">//合并两个结点所在集合，如果已在同一集合，返回false</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">unionSets</span><span class="hljs-params">(gg a, gg b)</span> </span>&#123;<br>  a = <span class="hljs-built_in">findRoot</span>(a), b = <span class="hljs-built_in">findRoot</span>(b);<br>  <span class="hljs-keyword">if</span> (a == b) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  ufs[a] = b;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span>* fa)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> (x==fa[x])?x:(fa[x]=<span class="hljs-built_in">find</span>(fa[x], fa));<br>&#125;<br>  <span class="hljs-keyword">private</span>:<br>    vector&lt;gg&gt; ufs;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆性质：父亲的权值不小于儿子的权值（大根堆）。同样的，我们可以定义小根堆。本文以大根堆为例。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">while</span> (x &gt; <span class="hljs-number">1</span> &amp;&amp; h[x] &gt; h[x / <span class="hljs-number">2</span>]) &#123;<br>    <span class="hljs-built_in">swap</span>(h[x], h[x / <span class="hljs-number">2</span>]);<br>    x /= <span class="hljs-number">2</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">while</span> (x * <span class="hljs-number">2</span> &lt;= n) &#123;<br>    t = x * <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (t + <span class="hljs-number">1</span> &lt;= n &amp;&amp; h[t + <span class="hljs-number">1</span>] &gt; h[t]) t++;<br>    <span class="hljs-keyword">if</span> (h[t] &lt;= h[x]) <span class="hljs-keyword">break</span>;<br>    std::<span class="hljs-built_in">swap</span>(h[x], h[t]);<br>    x = t;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><p>线段树是算法竞赛中常用的用来维护 <strong>区间信息</strong> 的数据结构。</p><p>线段树可以在 $O(logn)$ 的时间复杂度内实现单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值)等操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-type">int</span> n, a[<span class="hljs-number">100005</span>], d[<span class="hljs-number">270000</span>], b[<span class="hljs-number">270000</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (l == r) &#123;<br>    d[p] = a[l];<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-type">int</span> m = l + ((r - l) &gt;&gt; <span class="hljs-number">1</span>);<br>  <span class="hljs-built_in">build</span>(l, m, p &lt;&lt; <span class="hljs-number">1</span>), <span class="hljs-built_in">build</span>(m + <span class="hljs-number">1</span>, r, (p &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-number">1</span>);<br>  d[p] = d[p &lt;&lt; <span class="hljs-number">1</span>] + d[(p &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t,</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-type">int</span> p)</span> </span>&#123; <br>  <span class="hljs-keyword">if</span> (l &lt;= s &amp;&amp; t &lt;= r) &#123;<br>    d[p] = (t - s + <span class="hljs-number">1</span>) * c, b[p] = c;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-type">int</span> m = s + ((t - s) &gt;&gt; <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">if</span> (b[p]) &#123;<br>    d[p &lt;&lt; <span class="hljs-number">1</span>] = b[p] * (m - s + <span class="hljs-number">1</span>), d[(p &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-number">1</span>] = b[p] * (t - m);<br>    b[p &lt;&lt; <span class="hljs-number">1</span>] = b[(p &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-number">1</span>] = b[p];<br>    b[p] = <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (l &lt;= m) <span class="hljs-built_in">update</span>(l, r, c, s, m, p &lt;&lt; <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">if</span> (r &gt; m) <span class="hljs-built_in">update</span>(l, r, c, m + <span class="hljs-number">1</span>, t, (p &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-number">1</span>);<br>  d[p] = d[p &lt;&lt; <span class="hljs-number">1</span>] + d[(p &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> p)</span> </span>&#123;  <span class="hljs-comment">// 取得答案，和前面一样</span><br>  <span class="hljs-keyword">if</span> (l &lt;= s &amp;&amp; t &lt;= r) <span class="hljs-keyword">return</span> d[p];<br>  <span class="hljs-type">int</span> m = s + ((t - s) &gt;&gt; <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">if</span> (b[p]) &#123;<br>    d[p &lt;&lt; <span class="hljs-number">1</span>] = b[p] * (m - s + <span class="hljs-number">1</span>), d[(p &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-number">1</span>] = b[p] * (t - m);<br>    b[p &lt;&lt; <span class="hljs-number">1</span>] = b[(p &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-number">1</span>] = b[p];<br>    b[p] = <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (l &lt;= m) sum = <span class="hljs-built_in">getsum</span>(l, r, s, m, p &lt;&lt; <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">if</span> (r &gt; m) sum += <span class="hljs-built_in">getsum</span>(l, r, m + <span class="hljs-number">1</span>, t, (p &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>  std::cin &gt;&gt; n;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) std::cin &gt;&gt; a[i];<br>  <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, n, <span class="hljs-number">1</span>);<br>  <span class="hljs-type">int</span> q, i1, i2, i3, i4;<br>  std::cin &gt;&gt; q;<br>  <span class="hljs-keyword">while</span> (q--) &#123;<br>    std::cin &gt;&gt; i1 &gt;&gt; i2 &gt;&gt; i3;<br>    <span class="hljs-keyword">if</span> (i1 == <span class="hljs-number">0</span>)<br>      std::cout &lt;&lt; <span class="hljs-built_in">getsum</span>(i2, i3, <span class="hljs-number">1</span>, n, <span class="hljs-number">1</span>) &lt;&lt; std::endl;<br>    <span class="hljs-keyword">else</span><br>      std::cin &gt;&gt; i4, <span class="hljs-built_in">update</span>(i2, i3, i4, <span class="hljs-number">1</span>, n, <span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>下周把数据结构这部分写完，还剩二叉树内容，只打算补充 Splay 和 Treap</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>OI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>My First Blog</title>
    <link href="/2024/08/12/My-First-Blog/"/>
    <url>/2024/08/12/My-First-Blog/</url>
    
    <content type="html"><![CDATA[<p>This is my first blog</p><span id="more"></span><h1 id="First-Blog"><a href="#First-Blog" class="headerlink" title="First Blog"></a>First Blog</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">using</span> std::cout</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  cout&lt;&lt;<span class="hljs-string">&quot;hello world!&quot;</span>&lt;&lt;endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>helloworld</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
